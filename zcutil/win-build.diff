diff --git a/configure.ac b/configure.ac
index 8c19408..f96c06a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -502,8 +502,9 @@ if test x$use_hardening != xno; then
     HARDENED_CPPFLAGS="$HARDENED_CPPFLAGS -D_FORTIFY_SOURCE=2"
   ],[AC_MSG_ERROR(Cannot enable -D_FORTIFY_SOURCE=2)])
 
-  if test x$BUILD_OS = xdarwin; then
+  if test x$BUILD_OS = xdarwin || test x$TARGET_OS = xwindows; then
     # Xcode's ld (at least ld64-302.3) doesn't support -z
+    # mingw-w64's ld (at least mingw-w64 4.0.4-2) also appears to not support -z
     AX_CHECK_LINK_FLAG([[-Wl,-z,relro]], [HARDENED_LDFLAGS="$HARDENED_LDFLAGS -Wl,-z,relro"],[AC_MSG_WARN(Cannot enable RELRO)])
     AX_CHECK_LINK_FLAG([[-Wl,-z,now]], [HARDENED_LDFLAGS="$HARDENED_LDFLAGS -Wl,-z,now"],[AC_MSG_WARN(Cannot enable BIND_NOW)])
   else
@@ -764,7 +765,7 @@ AC_CHECK_LIB([gmp],[[__gmpn_sub_n]],GMP_LIBS=-lgmp, [AC_MSG_ERROR(libgmp missing
 AC_CHECK_HEADER([gmpxx.h],,AC_MSG_ERROR(libgmpxx headers missing))
 AC_CHECK_LIB([gmpxx],[main],GMPXX_LIBS=-lgmpxx, [AC_MSG_ERROR(libgmpxx missing)])
 
-RUST_LIBS="-lrustzcash -ldl"
+RUST_LIBS="-lrustzcash"
 
 dnl Check for OpenMP support
 AX_OPENMP(
diff --git a/depends/packages/googletest.mk b/depends/packages/googletest.mk
index b10ce89..ad42d5b 100644
--- a/depends/packages/googletest.mk
+++ b/depends/packages/googletest.mk
@@ -5,9 +5,14 @@ $(package)_file_name=$(package)-$($(package)_version).tar.gz
 $(package)_download_file=release-$($(package)_version).tar.gz
 $(package)_sha256_hash=58a6f4277ca2bc8565222b3bbd58a177609e9c488e8a72649359ba51450db7d8
 
+define $(package)_set_vars
+$(package)_cxxflags+=-std=c++11
+$(package)_cxxflags_linux=-fPIC
+endef
+
 define $(package)_build_cmds
-  $(MAKE) -C googlemock/make CXXFLAGS=-fPIC gmock.a && \
-  $(MAKE) -C googletest/make CXXFLAGS=-fPIC gtest.a
+  $(MAKE) -C googlemock/make CC="$($(package)_cc)" CXX="$($(package)_cxx)" AR="$($(package)_ar)" CXXFLAGS="$($(package)_cxxflags)" gmock.a && \
+  $(MAKE) -C googletest/make CC="$($(package)_cc)" CXX="$($(package)_cxx)" AR="$($(package)_ar)" CXXFLAGS="$($(package)_cxxflags)" gtest.a
 endef
 
 define $(package)_stage_cmds
diff --git a/depends/packages/librustzcash.mk b/depends/packages/librustzcash.mk
index 11ee085..cc84c19 100644
--- a/depends/packages/librustzcash.mk
+++ b/depends/packages/librustzcash.mk
@@ -8,18 +8,29 @@ $(package)_git_commit=0af1ce8bf121e1ad367db907c39d214581e270a6
 $(package)_dependencies=rust $(rust_crates)
 $(package)_patches=cargo.config
 
+ifeq ($(host_os),mingw32)
+$(package)_library_file=target/x86_64-pc-windows-gnu/release/rustzcash.lib
+else
+$(package)_library_file=target/release/librustzcash.a
+endif
+
+define $(package)_set_vars
+$(package)_build_opts=--frozen --release
+$(package)_build_opts_mingw32=--target=x86_64-pc-windows-gnu
+endef
+
 define $(package)_preprocess_cmds
   mkdir .cargo && \
   cat $($(package)_patch_dir)/cargo.config | sed 's|CRATE_REGISTRY|$(host_prefix)/$(CRATE_REGISTRY)|' > .cargo/config
 endef
 
 define $(package)_build_cmds
-  cargo build --frozen --release
+  cargo build $($(package)_build_opts)
 endef
 
 define $(package)_stage_cmds
   mkdir $($(package)_staging_dir)$(host_prefix)/lib/ && \
   mkdir $($(package)_staging_dir)$(host_prefix)/include/ && \
-  cp target/release/librustzcash.a $($(package)_staging_dir)$(host_prefix)/lib/ && \
+  cp $($(package)_library_file) $($(package)_staging_dir)$(host_prefix)/lib/ && \
   cp include/librustzcash.h $($(package)_staging_dir)$(host_prefix)/include/
 endef
diff --git a/depends/packages/rust.mk b/depends/packages/rust.mk
index 07665ce..ccc4a19 100644
--- a/depends/packages/rust.mk
+++ b/depends/packages/rust.mk
@@ -5,10 +5,36 @@ $(package)_file_name_linux=rust-$($(package)_version)-x86_64-unknown-linux-gnu.t
 $(package)_sha256_hash_linux=13691d7782577fc9f110924b26603ade1990de0b691a3ce2dc324b4a72a64a68
 $(package)_file_name_darwin=rust-$($(package)_version)-x86_64-apple-darwin.tar.gz
 $(package)_sha256_hash_darwin=38708803c3096b8f101d1919ee2d7e723b0adf1bc1bb986b060973b57d8c7c28
-$(package)_file_name_mingw32=rust-mingw-$($(package)_version)-x86_64-pc-windows-gnu.tar.gz
-$(package)_sha256_hash_mingw32=156f99baf34a7a52867879cde17b762481c49aa280ca1b8fee3c4c5b7b43a408
+$(package)_file_name_mingw32=rust-$($(package)_version)-x86_64-pc-windows-gnu.tar.gz
+$(package)_sha256_hash_mingw32=4586d69edcb22f7ebd651cd305dce67ead065e8a60994a7d64fc8b472fc4e51b
 
+ifeq ($(host_os),mingw32)
+$(package)_build_subdir=buildos
+$(package)_extra_sources = $($(package)_file_name_$(build_os))
+
+define $(package)_fetch_cmds
+$(call fetch_file,$(package),$($(package)_download_path),$($(package)_download_file),$($(package)_file_name),$($(package)_sha256_hash)) && \
+$(call fetch_file,$(package),$($(package)_download_path),$($(package)_file_name_$(build_os)),$($(package)_file_name_$(build_os)),$($(package)_sha256_hash_$(build_os)))
+endef
+
+define $(package)_extract_cmds
+  mkdir -p $($(package)_extract_dir) && \
+  echo "$($(package)_sha256_hash)  $($(package)_source)" > $($(package)_extract_dir)/.$($(package)_file_name).hash && \
+  echo "$($(package)_sha256_hash_$(build_os))  $($(package)_source_dir)/$($(package)_file_name_$(build_os))" >> $($(package)_extract_dir)/.$($(package)_file_name).hash && \
+  $(build_SHA256SUM) -c $($(package)_extract_dir)/.$($(package)_file_name).hash && \
+  mkdir mingw32 && \
+  tar --strip-components=1 -xf $($(package)_source) -C mingw32 && \
+  mkdir buildos && \
+  tar --strip-components=1 -xf $($(package)_source_dir)/$($(package)_file_name_$(build_os)) -C buildos
+endef
+
+define $(package)_stage_cmds
+  ./install.sh --destdir=$($(package)_staging_dir) --prefix=$(host_prefix)/native --disable-ldconfig && \
+  cp -r ../mingw32/rust-std-x86_64-pc-windows-gnu/lib/rustlib/x86_64-pc-windows-gnu $($(package)_staging_dir)$(host_prefix)/native/lib/rustlib
+endef
+else
 
 define $(package)_stage_cmds
   ./install.sh --destdir=$($(package)_staging_dir) --prefix=$(host_prefix)/native --disable-ldconfig
 endef
+endif
diff --git a/depends/patches/librustzcash/cargo.config b/depends/patches/librustzcash/cargo.config
index 234a9c9..6fafa20 100644
--- a/depends/patches/librustzcash/cargo.config
+++ b/depends/patches/librustzcash/cargo.config
@@ -13,3 +13,6 @@ replace-with = "vendored-sources"
 
 [source.vendored-sources]
 directory = "CRATE_REGISTRY"
+
+[target.x86_64-pc-windows-gnu]
+linker = "x86_64-w64-mingw32-gcc"
diff --git a/src/Makefile.am b/src/Makefile.am
index b047ce4..b374926 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -42,7 +42,7 @@ LIBBITCOINQT=qt/libbitcoinqt.a
 $(LIBSECP256K1): $(wildcard secp256k1/src/*) $(wildcard secp256k1/include/*)
 	$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C $(@D) $(@F)
 
-LIBSNARK_CXXFLAGS = -fPIC -DBINARY_OUTPUT -DNO_PT_COMPRESSION=1 -fstack-protector-all
+LIBSNARK_CXXFLAGS = $(AM_CXXFLAGS) $(PIC_FLAGS) -DBINARY_OUTPUT -DNO_PT_COMPRESSION=1 -fstack-protector-all
 LIBSNARK_CONFIG_FLAGS = CURVE=ALT_BN128 NO_PROCPS=1 NO_DOCS=1 STATIC=1 NO_SUPERCOP=1 FEATUREFLAGS=-DMONTGOMERY_OUTPUT NO_COPY_DEPINST=1 NO_COMPILE_LIBGTEST=1
 if HAVE_OPENMP
 LIBSNARK_CONFIG_FLAGS += MULTICORE=1
@@ -52,10 +52,10 @@ LIBSNARK_CONFIG_FLAGS += PLATFORM=darwin
 endif
 
 $(LIBSNARK): $(wildcard snark/libsnark/*)
-	$(AM_V_at) CXXFLAGS="$(LIBSNARK_CXXFLAGS)" $(MAKE) $(AM_MAKEFLAGS) -C snark/ DEPINST="$(LIBSNARK_DEPINST)" $(LIBSNARK_CONFIG_FLAGS) OPTFLAGS="-O2 -march=x86-64"
+	$(AM_V_at) CC="$(CC)" CXX="$(CXX)" AR="$(AR)" CXXFLAGS="$(LIBSNARK_CXXFLAGS)" $(MAKE) $(AM_MAKEFLAGS) -C snark/ DEPINST="$(LIBSNARK_DEPINST)" $(LIBSNARK_CONFIG_FLAGS) OPTFLAGS="-O2 -march=x86-64"
 
 libsnark-tests: $(wildcard snark/libsnark/*)
-	$(AM_V_at) CXXFLAGS="$(LIBSNARK_CXXFLAGS)" $(MAKE) $(AM_MAKEFLAGS) -C snark/ check DEPINST="$(LIBSNARK_DEPINST)" $(LIBSNARK_CONFIG_FLAGS) OPTFLAGS="-O2 -march=x86-64"
+	$(AM_V_at) CC="$(CC)" CXX="$(CXX)" AR="$(AR)" CXXFLAGS="$(LIBSNARK_CXXFLAGS)" $(MAKE) $(AM_MAKEFLAGS) -C snark/ check DEPINST="$(LIBSNARK_DEPINST)" $(LIBSNARK_CONFIG_FLAGS) OPTFLAGS="-O2 -march=x86-64"
 
 $(LIBUNIVALUE): $(wildcard univalue/lib/*) $(wildcard univalue/include/*)
 	$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C $(@D) $(@F)
@@ -538,11 +538,9 @@ libzcash_a_SOURCES = \
   zcash/circuit/prfs.tcc \
   zcash/circuit/utils.tcc
 
-libzcash_a_CPPFLAGS = -fPIC -DBINARY_OUTPUT -DCURVE_ALT_BN128 -DBOOST_SPIRIT_THREADSAFE -DHAVE_BUILD_INFO -D__STDC_FORMAT_MACROS $(HARDENED_CPPFLAGS) $(HARDENED_CXXFLAGS) $(HARDENED_LDFLAGS) -pipe $(SAN_LDFLAGS) -O1 -g -Wstack-protector $(SAN_CXXFLAGS) -fstack-protector-all -fPIE -fvisibility=hidden -DSTATIC $(BITCOIN_INCLUDES)
-
-libzcash_a_CXXFLAGS = $(SAN_CXXFLAGS) $(HARDENED_CXXFLAGS) -fwrapv -fno-strict-aliasing
-
-libzcash_a_LDFLAGS = $(SAN_LDFLAGS) $(HARDENED_LDFLAGS)
+libzcash_a_CPPFLAGS = $(AM_CPPFLAGS) $(PIC_FLAGS) -DBINARY_OUTPUT -DCURVE_ALT_BN128 -DBOOST_SPIRIT_THREADSAFE -fvisibility=hidden -DSTATIC $(BITCOIN_INCLUDES)
+libzcash_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)
+libzcash_a_LDFLAGS = $(AM_LDFLAGS)
 
 libzcash_a_CPPFLAGS += -DMONTGOMERY_OUTPUT
 
@@ -593,7 +591,8 @@ clean-local:
 
 .rc.o:
 	@test -f $(WINDRES)
-	$(AM_V_GEN) $(WINDRES) -DWINDRES_PREPROC -i $< -o $@
+	## FIXME: How to get the appropriate modulename_CPPFLAGS in here?
+	$(AM_V_GEN) $(WINDRES) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(CPPFLAGS) -DWINDRES_PREPROC -i $< -o $@
 
 .mm.o:
 	$(AM_V_CXX) $(OBJCXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
diff --git a/src/gtest/test_paymentdisclosure.cpp b/src/gtest/test_paymentdisclosure.cpp
index 77b0e24..1514a82 100644
--- a/src/gtest/test_paymentdisclosure.cpp
+++ b/src/gtest/test_paymentdisclosure.cpp
@@ -100,7 +100,7 @@ TEST(paymentdisclosure, mainnet) {
     boost::filesystem::create_directories(pathTemp);
     mapArgs["-datadir"] = pathTemp.string();
 
-    std::cout << "Test payment disclosure database created in folder: " << pathTemp.native() << std::endl;
+    std::cout << "Test payment disclosure database created in folder: " << pathTemp.string() << std::endl;
 
     PaymentDisclosureDBTest mydb(pathTemp);
 
diff --git a/src/metrics.cpp b/src/metrics.cpp
index 0e0c77f..ef8f0bd 100644
--- a/src/metrics.cpp
+++ b/src/metrics.cpp
@@ -19,7 +19,6 @@
 
 #ifdef WIN32
 #include <io.h>
-#include <windows.h>
 #else
 #include <sys/ioctl.h>
 #endif
@@ -421,6 +420,8 @@ int printInitMessage()
 }
 
 #ifdef WIN32
+#define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
+
 void setCursorPosition(int x, int y)
 {
     static const HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
@@ -428,6 +429,26 @@ void setCursorPosition(int x, int y)
     COORD coord = { (SHORT)x, (SHORT)y };
     SetConsoleCursorPosition(hOut, coord);
 }
+
+bool enableVTMode()
+{
+    // Set output mode to handle virtual terminal sequences
+    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
+    if (hOut == INVALID_HANDLE_VALUE) {
+        return false;
+    }
+
+    DWORD dwMode = 0;
+    if (!GetConsoleMode(hOut, &dwMode)) {
+        return false;
+    }
+
+    dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
+    if (!SetConsoleMode(hOut, dwMode)) {
+        return false;
+    }
+    return true;
+}
 #endif
 
 void ThreadShowMetricsScreen()
@@ -435,23 +456,18 @@ void ThreadShowMetricsScreen()
     // Make this thread recognisable as the metrics screen thread
     RenameThread("koto-metrics-screen");
 
-#ifdef WIN32
-    bool clearedAfterLoaded = false;
-#endif
-
     // Determine whether we should render a persistent UI or rolling metrics
     bool isTTY = isatty(STDOUT_FILENO);
     bool isScreen = GetBoolArg("-metricsui", isTTY);
     int64_t nRefresh = GetArg("-metricsrefreshtime", isTTY ? 1 : 600);
 
     if (isScreen) {
-        // Clear screen
 #ifdef WIN32
-        setCursorPosition(0, 0);
-#else
-        std::cout << "\e[2J";
+        enableVTMode();
 #endif
 
+        std::cout << "\e[2J";
+
         // Print art
         std::cout << METRICS_ART << std::endl;
         std::cout << std::endl;
@@ -474,9 +490,9 @@ void ThreadShowMetricsScreen()
         if (isTTY) {
 
 #ifdef WIN32
-        CONSOLE_SCREEN_BUFFER_INFO csbi;
-        GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
-        cols = csbi.srWindow.Right - csbi.srWindow.Left + 1;
+            CONSOLE_SCREEN_BUFFER_INFO csbi;
+            GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
+            cols = csbi.srWindow.Right - csbi.srWindow.Left + 1;
 #else
             struct winsize w;
             w.ws_col = 0;
@@ -487,28 +503,8 @@ void ThreadShowMetricsScreen()
         }
 
         if (isScreen) {
-#ifdef WIN32
-        setCursorPosition(0, 12);
-        if (loaded)
-        {
-           if (!clearedAfterLoaded)
-           {
-              std::cout << std::string(cols, ' ');
-              std::cout << std::string(cols, ' ');
-              std::cout << std::string(cols, ' ');
-              std::cout << std::string(cols, ' ');
-              std::cout << std::string(cols, ' ');
-              std::cout << std::string(cols, ' ');
-              std::cout << std::string(cols, ' ');
-              std::cout << std::string(cols, ' ');
-              setCursorPosition(0, 12);
-           }
-           clearedAfterLoaded=true;
-        }
-#else
             // Erase below current position
             std::cout << "\e[J";
-#endif
         }
 
         // Miner status
@@ -528,7 +524,13 @@ void ThreadShowMetricsScreen()
 
         if (isScreen) {
             // Explain how to exit
-            std::cout << "[" << _("Press Ctrl+C to exit") << "] [" << _("Set 'showmetrics=0' to hide") << "]" << std::endl;
+            std::cout << "[";
+#ifdef WIN32
+            std::cout << _("'koto-cli.exe stop' to exit");
+#else
+            std::cout << _("Press Ctrl+C to exit");
+#endif
+            std::cout << "] [" << _("Set 'showmetrics=0' to hide") << "]" << std::endl;
         } else {
             // Print delineator
             std::cout << "----------------------------------------" << std::endl;
@@ -542,11 +544,7 @@ void ThreadShowMetricsScreen()
 
         if (isScreen) {
             // Return to the top of the updating section
-#ifdef WIN32
-            setCursorPosition(0, 12);
-#else
             std::cout << "\e[" << lines << "A";
-#endif
         }
     }
 }
diff --git a/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_g1.cpp b/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_g1.cpp
index bf7f43d..2c62060 100644
--- a/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_g1.cpp
+++ b/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_g1.cpp
@@ -10,8 +10,8 @@
 namespace libsnark {
 
 #ifdef PROFILE_OP_COUNTS
-long long alt_bn128_G1::add_cnt = 0;
-long long alt_bn128_G1::dbl_cnt = 0;
+int64_t alt_bn128_G1::add_cnt = 0;
+int64_t alt_bn128_G1::dbl_cnt = 0;
 #endif
 
 std::vector<size_t> alt_bn128_G1::wnaf_window_table;
diff --git a/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_g1.hpp b/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_g1.hpp
index da11a2e..7053fe6 100644
--- a/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_g1.hpp
+++ b/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_g1.hpp
@@ -20,8 +20,8 @@ std::istream& operator>>(std::istream &, alt_bn128_G1&);
 class alt_bn128_G1 {
 public:
 #ifdef PROFILE_OP_COUNTS
-    static long long add_cnt;
-    static long long dbl_cnt;
+    static int64_t add_cnt;
+    static int64_t dbl_cnt;
 #endif
     static std::vector<size_t> wnaf_window_table;
     static std::vector<size_t> fixed_base_exp_window_table;
diff --git a/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_g2.cpp b/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_g2.cpp
index c4152e4..4b592e8 100644
--- a/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_g2.cpp
+++ b/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_g2.cpp
@@ -10,8 +10,8 @@
 namespace libsnark {
 
 #ifdef PROFILE_OP_COUNTS
-long long alt_bn128_G2::add_cnt = 0;
-long long alt_bn128_G2::dbl_cnt = 0;
+int64_t alt_bn128_G2::add_cnt = 0;
+int64_t alt_bn128_G2::dbl_cnt = 0;
 #endif
 
 std::vector<size_t> alt_bn128_G2::wnaf_window_table;
diff --git a/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_g2.hpp b/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_g2.hpp
index a996a2d..d6fa6a1 100644
--- a/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_g2.hpp
+++ b/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_g2.hpp
@@ -20,8 +20,8 @@ std::istream& operator>>(std::istream &, alt_bn128_G2&);
 class alt_bn128_G2 {
 public:
 #ifdef PROFILE_OP_COUNTS
-    static long long add_cnt;
-    static long long dbl_cnt;
+    static int64_t add_cnt;
+    static int64_t dbl_cnt;
 #endif
     static std::vector<size_t> wnaf_window_table;
     static std::vector<size_t> fixed_base_exp_window_table;
diff --git a/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_pairing.cpp b/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_pairing.cpp
index db556c5..07b6a8c 100644
--- a/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_pairing.cpp
+++ b/src/snark/libsnark/algebra/curves/alt_bn128/alt_bn128_pairing.cpp
@@ -324,7 +324,7 @@ alt_bn128_ate_G2_precomp alt_bn128_ate_precompute_G2(const alt_bn128_G2& Q)
     bool found_one = false;
     alt_bn128_ate_ell_coeffs c;
 
-    for (long i = loop_count.max_bits(); i >= 0; --i)
+    for (int64_t i = loop_count.max_bits(); i >= 0; --i)
     {
         const bool bit = loop_count.test_bit(i);
         if (!found_one)
@@ -378,7 +378,7 @@ alt_bn128_Fq12 alt_bn128_ate_miller_loop(const alt_bn128_ate_G1_precomp &prec_P,
     const bigint<alt_bn128_Fr::num_limbs> &loop_count = alt_bn128_ate_loop_count;
     alt_bn128_ate_ell_coeffs c;
 
-    for (long i = loop_count.max_bits(); i >= 0; --i)
+    for (int64_t i = loop_count.max_bits(); i >= 0; --i)
     {
         const bool bit = loop_count.test_bit(i);
         if (!found_one)
@@ -432,7 +432,7 @@ alt_bn128_Fq12 alt_bn128_ate_double_miller_loop(const alt_bn128_ate_G1_precomp &
     size_t idx = 0;
 
     const bigint<alt_bn128_Fr::num_limbs> &loop_count = alt_bn128_ate_loop_count;
-    for (long i = loop_count.max_bits(); i >= 0; --i)
+    for (int64_t i = loop_count.max_bits(); i >= 0; --i)
     {
         const bool bit = loop_count.test_bit(i);
         if (!found_one)
diff --git a/src/snark/libsnark/algebra/curves/curve_utils.tcc b/src/snark/libsnark/algebra/curves/curve_utils.tcc
index 251d75d..38140cd 100644
--- a/src/snark/libsnark/algebra/curves/curve_utils.tcc
+++ b/src/snark/libsnark/algebra/curves/curve_utils.tcc
@@ -16,7 +16,7 @@ GroupT scalar_mul(const GroupT &base, const bigint<m> &scalar)
     GroupT result = GroupT::zero();
 
     bool found_one = false;
-    for (long i = scalar.max_bits() - 1; i >= 0; --i)
+    for (int64_t i = scalar.max_bits() - 1; i >= 0; --i)
     {
         if (found_one)
         {
diff --git a/src/snark/libsnark/algebra/evaluation_domain/domains/basic_radix2_domain_aux.tcc b/src/snark/libsnark/algebra/evaluation_domain/domains/basic_radix2_domain_aux.tcc
index 138b82d..79f2ffe 100644
--- a/src/snark/libsnark/algebra/evaluation_domain/domains/basic_radix2_domain_aux.tcc
+++ b/src/snark/libsnark/algebra/evaluation_domain/domains/basic_radix2_domain_aux.tcc
@@ -74,11 +74,11 @@ void _basic_serial_radix2_FFT(std::vector<FieldT> &a, const FieldT &omega)
 template<typename FieldT>
 void _basic_parallel_radix2_FFT_inner(std::vector<FieldT> &a, const FieldT &omega, const size_t log_cpus)
 {
-    const size_t num_cpus = 1ul<<log_cpus;
+    const size_t num_cpus = UINT64_C(1)<<log_cpus;
 
     const size_t m = a.size();
     const size_t log_m = log2(m);
-    assert(m == 1ul<<log_m);
+    assert(m == UINT64_C(1)<<log_m);
 
     if (log_m < log_cpus)
     {
@@ -90,7 +90,7 @@ void _basic_parallel_radix2_FFT_inner(std::vector<FieldT> &a, const FieldT &omeg
     std::vector<std::vector<FieldT> > tmp(num_cpus);
     for (size_t j = 0; j < num_cpus; ++j)
     {
-        tmp[j].resize(1ul<<(log_m-log_cpus), FieldT::zero());
+        tmp[j].resize(UINT64_C(1)<<(log_m-log_cpus), FieldT::zero());
     }
 
 #ifdef MULTICORE
@@ -102,7 +102,7 @@ void _basic_parallel_radix2_FFT_inner(std::vector<FieldT> &a, const FieldT &omeg
         const FieldT omega_step = omega^(j<<(log_m - log_cpus));
 
         FieldT elt = FieldT::one();
-        for (size_t i = 0; i < 1ul<<(log_m - log_cpus); ++i)
+        for (size_t i = 0; i < UINT64_C(1)<<(log_m - log_cpus); ++i)
         {
             for (size_t s = 0; s < num_cpus; ++s)
             {
@@ -135,7 +135,7 @@ void _basic_parallel_radix2_FFT_inner(std::vector<FieldT> &a, const FieldT &omeg
 #endif
     for (size_t i = 0; i < num_cpus; ++i)
     {
-        for (size_t j = 0; j < 1ul<<(log_m - log_cpus); ++j)
+        for (size_t j = 0; j < UINT64_C(1)<<(log_m - log_cpus); ++j)
         {
             // now: i = idx >> (log_m - log_cpus) and j = idx % (1u << (log_m - log_cpus)), for idx = ((i<<(log_m-log_cpus))+j) % (1u << log_m)
             a[(j<<log_cpus) + i] = tmp[i][j];
diff --git a/src/snark/libsnark/algebra/evaluation_domain/evaluation_domain.tcc b/src/snark/libsnark/algebra/evaluation_domain/evaluation_domain.tcc
index 8e3ea7a..ec58ad8 100644
--- a/src/snark/libsnark/algebra/evaluation_domain/evaluation_domain.tcc
+++ b/src/snark/libsnark/algebra/evaluation_domain/evaluation_domain.tcc
@@ -54,9 +54,9 @@ std::shared_ptr<evaluation_domain<FieldT> > get_evaluation_domain(const size_t m
     }
     else
     {
-        const size_t big = 1ul<<(log2(min_size)-1);
+        const size_t big = UINT64_C(1)<<(log2(min_size)-1);
         const size_t small = min_size - big;
-        const size_t rounded_small = (1ul<<log2(small));
+        const size_t rounded_small = (UINT64_C(1)<<log2(small));
         if (big == rounded_small)
         {
             if (log2(big + rounded_small) < FieldT::s+1)
diff --git a/src/snark/libsnark/algebra/exponentiation/exponentiation.hpp b/src/snark/libsnark/algebra/exponentiation/exponentiation.hpp
index a8a2c92..836ebf0 100644
--- a/src/snark/libsnark/algebra/exponentiation/exponentiation.hpp
+++ b/src/snark/libsnark/algebra/exponentiation/exponentiation.hpp
@@ -22,7 +22,7 @@ template<typename FieldT, mp_size_t m>
 FieldT power(const FieldT &base, const bigint<m> &exponent);
 
 template<typename FieldT>
-FieldT power(const FieldT &base, const unsigned long exponent);
+FieldT power(const FieldT &base, const uint64_t exponent);
 
 } // libsnark
 
diff --git a/src/snark/libsnark/algebra/exponentiation/exponentiation.tcc b/src/snark/libsnark/algebra/exponentiation/exponentiation.tcc
index dd557eb..7ac3bf5 100644
--- a/src/snark/libsnark/algebra/exponentiation/exponentiation.tcc
+++ b/src/snark/libsnark/algebra/exponentiation/exponentiation.tcc
@@ -25,7 +25,7 @@ FieldT power(const FieldT &base, const bigint<m> &exponent)
 
     bool found_one = false;
 
-    for (long i = exponent.max_bits() - 1; i >= 0; --i)
+    for (int64_t i = exponent.max_bits() - 1; i >= 0; --i)
     {
         if (found_one)
         {
@@ -43,7 +43,7 @@ FieldT power(const FieldT &base, const bigint<m> &exponent)
 }
 
 template<typename FieldT>
-FieldT power(const FieldT &base, const unsigned long exponent)
+FieldT power(const FieldT &base, const uint64_t exponent)
 {
     return power<FieldT>(base, bigint<1>(exponent));
 }
diff --git a/src/snark/libsnark/algebra/fields/bigint.hpp b/src/snark/libsnark/algebra/fields/bigint.hpp
index 50f78b7..dc47a7e 100644
--- a/src/snark/libsnark/algebra/fields/bigint.hpp
+++ b/src/snark/libsnark/algebra/fields/bigint.hpp
@@ -33,7 +33,7 @@ public:
     mp_limb_t data[n] = {0};
 
     bigint() = default;
-    bigint(const unsigned long x); /// Initialize from a small integer
+    bigint(const uint64_t x); /// Initalize from a small integer
     bigint(const char* s); /// Initialize from a string containing an integer in decimal notation
     bigint(const mpz_t r); /// Initialize from MPZ element
 
@@ -46,7 +46,7 @@ public:
     size_t max_bits() const { return n * GMP_NUMB_BITS; }
     size_t num_bits() const;
 
-    unsigned long as_ulong() const; /* return the last limb of the integer */
+    uint64_t as_ulong() const; /* return the last limb of the integer */
     void to_mpz(mpz_t r) const;
     bool test_bit(const std::size_t bitno) const;
 
diff --git a/src/snark/libsnark/algebra/fields/bigint.tcc b/src/snark/libsnark/algebra/fields/bigint.tcc
index 81befd9..29608cd 100644
--- a/src/snark/libsnark/algebra/fields/bigint.tcc
+++ b/src/snark/libsnark/algebra/fields/bigint.tcc
@@ -17,9 +17,9 @@
 namespace libsnark {
 
 template<mp_size_t n>
-bigint<n>::bigint(const unsigned long x) /// Initialize from a small integer
+bigint<n>::bigint(const uint64_t x) /// Initialize from a small integer
 {
-    static_assert(ULONG_MAX <= GMP_NUMB_MAX, "unsigned long does not fit in a GMP limb");
+    static_assert(UINT64_MAX <= GMP_NUMB_MAX, "uint64_t does not fit in a GMP limb");
     this->data[0] = x;
 }
 
@@ -105,7 +105,7 @@ template<mp_size_t n>
 size_t bigint<n>::num_bits() const
 {
 /*
-    for (long i = max_bits(); i >= 0; --i)
+    for (int64_t i = max_bits(); i >= 0; --i)
     {
         if (this->test_bit(i))
         {
@@ -115,7 +115,7 @@ size_t bigint<n>::num_bits() const
 
     return 0;
 */
-    for (long i = n-1; i >= 0; --i)
+    for (int64_t i = n-1; i >= 0; --i)
     {
         mp_limb_t x = this->data[i];
         if (x == 0)
@@ -124,14 +124,14 @@ size_t bigint<n>::num_bits() const
         }
         else
         {
-            return ((i+1) * GMP_NUMB_BITS) - __builtin_clzl(x);
+            return ((i+1) * GMP_NUMB_BITS) - __builtin_clzll(x);
         }
     }
     return 0;
 }
 
 template<mp_size_t n>
-unsigned long bigint<n>::as_ulong() const
+uint64_t bigint<n>::as_ulong() const
 {
     return this->data[0];
 }
diff --git a/src/snark/libsnark/algebra/fields/field_utils.tcc b/src/snark/libsnark/algebra/fields/field_utils.tcc
index 13197b2..66b5323 100644
--- a/src/snark/libsnark/algebra/fields/field_utils.tcc
+++ b/src/snark/libsnark/algebra/fields/field_utils.tcc
@@ -171,7 +171,7 @@ void batch_invert(std::vector<FieldT> &vec)
 
     FieldT acc_inverse = acc.inverse();
 
-    for (long i = vec.size()-1; i >= 0; --i)
+    for (int64_t i = vec.size()-1; i >= 0; --i)
     {
         const FieldT old_el = vec[i];
         vec[i] = acc_inverse * prod[i];
diff --git a/src/snark/libsnark/algebra/fields/fp.hpp b/src/snark/libsnark/algebra/fields/fp.hpp
index 9679275..5baf20a 100644
--- a/src/snark/libsnark/algebra/fields/fp.hpp
+++ b/src/snark/libsnark/algebra/fields/fp.hpp
@@ -44,11 +44,11 @@ public:
     static const mp_size_t num_limbs = n;
     static const constexpr bigint<n>& mod = modulus;
 #ifdef PROFILE_OP_COUNTS
-    static long long add_cnt;
-    static long long sub_cnt;
-    static long long mul_cnt;
-    static long long sqr_cnt;
-    static long long inv_cnt;
+    static int64_t add_cnt;
+    static int64_t sub_cnt;
+    static int64_t mul_cnt;
+    static int64_t sqr_cnt;
+    static int64_t inv_cnt;
 #endif
     static size_t num_bits;
     static bigint<n> euler; // (modulus-1)/2
@@ -67,9 +67,9 @@ public:
 
     Fp_model() {};
     Fp_model(const bigint<n> &b);
-    Fp_model(const long x, const bool is_unsigned=false);
+    Fp_model(const int64_t x, const bool is_unsigned=false);
 
-    void set_ulong(const unsigned long x);
+    void set_ulong(const uint64_t x);
 
     void mul_reduce(const bigint<n> &other);
 
@@ -82,7 +82,7 @@ public:
     /* Return the last limb of the standard representation of the
        field element. E.g. on 64-bit architectures Fp(123).as_ulong()
        and Fp(2^64+123).as_ulong() would both return 123. */
-    unsigned long as_ulong() const;
+    uint64_t as_ulong() const;
 
     bool operator==(const Fp_model& other) const;
     bool operator!=(const Fp_model& other) const;
@@ -93,7 +93,7 @@ public:
     Fp_model& operator+=(const Fp_model& other);
     Fp_model& operator-=(const Fp_model& other);
     Fp_model& operator*=(const Fp_model& other);
-    Fp_model& operator^=(const unsigned long pow);
+    Fp_model& operator^=(const uint64_t pow);
 
     template<mp_size_t m>
     Fp_model& operator^=(const bigint<m> &pow);
@@ -107,7 +107,7 @@ public:
     Fp_model inverse() const;
     Fp_model sqrt() const; // HAS TO BE A SQUARE (else does not terminate)
 
-    Fp_model operator^(const unsigned long pow) const;
+    Fp_model operator^(const uint64_t pow) const;
     template<mp_size_t m>
     Fp_model operator^(const bigint<m> &pow) const;
 
@@ -125,19 +125,19 @@ public:
 
 #ifdef PROFILE_OP_COUNTS
 template<mp_size_t n, const bigint<n>& modulus>
-long long Fp_model<n, modulus>::add_cnt = 0;
+int64_t Fp_model<n, modulus>::add_cnt = 0;
 
 template<mp_size_t n, const bigint<n>& modulus>
-long long Fp_model<n, modulus>::sub_cnt = 0;
+int64_t Fp_model<n, modulus>::sub_cnt = 0;
 
 template<mp_size_t n, const bigint<n>& modulus>
-long long Fp_model<n, modulus>::mul_cnt = 0;
+int64_t Fp_model<n, modulus>::mul_cnt = 0;
 
 template<mp_size_t n, const bigint<n>& modulus>
-long long Fp_model<n, modulus>::sqr_cnt = 0;
+int64_t Fp_model<n, modulus>::sqr_cnt = 0;
 
 template<mp_size_t n, const bigint<n>& modulus>
-long long Fp_model<n, modulus>::inv_cnt = 0;
+int64_t Fp_model<n, modulus>::inv_cnt = 0;
 #endif
 
 template<mp_size_t n, const bigint<n>& modulus>
diff --git a/src/snark/libsnark/algebra/fields/fp.tcc b/src/snark/libsnark/algebra/fields/fp.tcc
index 566e993..25b723c 100644
--- a/src/snark/libsnark/algebra/fields/fp.tcc
+++ b/src/snark/libsnark/algebra/fields/fp.tcc
@@ -194,7 +194,7 @@ Fp_model<n,modulus>::Fp_model(const bigint<n> &b)
 }
 
 template<mp_size_t n, const bigint<n>& modulus>
-Fp_model<n,modulus>::Fp_model(const long x, const bool is_unsigned)
+Fp_model<n,modulus>::Fp_model(const int64_t x, const bool is_unsigned)
 {
     if (is_unsigned || x >= 0)
     {
@@ -210,7 +210,7 @@ Fp_model<n,modulus>::Fp_model(const long x, const bool is_unsigned)
 }
 
 template<mp_size_t n, const bigint<n>& modulus>
-void Fp_model<n,modulus>::set_ulong(const unsigned long x)
+void Fp_model<n,modulus>::set_ulong(const uint64_t x)
 {
     this->mont_repr.clear();
     this->mont_repr.data[0] = x;
@@ -237,7 +237,7 @@ bigint<n> Fp_model<n,modulus>::as_bigint() const
 }
 
 template<mp_size_t n, const bigint<n>& modulus>
-unsigned long Fp_model<n,modulus>::as_ulong() const
+uint64_t Fp_model<n,modulus>::as_ulong() const
 {
     return this->as_bigint().as_ulong();
 }
@@ -502,7 +502,7 @@ Fp_model<n,modulus>& Fp_model<n,modulus>::operator*=(const Fp_model<n,modulus>&
 }
 
 template<mp_size_t n, const bigint<n>& modulus>
-Fp_model<n,modulus>& Fp_model<n,modulus>::operator^=(const unsigned long pow)
+Fp_model<n,modulus>& Fp_model<n,modulus>::operator^=(const uint64_t pow)
 {
     (*this) = power<Fp_model<n, modulus> >(*this, pow);
     return (*this);
@@ -538,7 +538,7 @@ Fp_model<n,modulus> Fp_model<n,modulus>::operator*(const Fp_model<n,modulus>& ot
 }
 
 template<mp_size_t n, const bigint<n>& modulus>
-Fp_model<n,modulus> Fp_model<n,modulus>::operator^(const unsigned long pow) const
+Fp_model<n,modulus> Fp_model<n,modulus>::operator^(const uint64_t pow) const
 {
     Fp_model<n, modulus> r(*this);
     return (r ^= pow);
@@ -690,7 +690,7 @@ Fp_model<n, modulus> Fp_model<n,modulus>::random_element() /// returns random el
             const std::size_t part = bitno/GMP_NUMB_BITS;
             const std::size_t bit = bitno - (GMP_NUMB_BITS*part);
 
-            r.mont_repr.data[part] &= ~(1ul<<bit);
+            r.mont_repr.data[part] &= ~(UINT64_C(1)<<bit);
 
             bitno--;
         }
diff --git a/src/snark/libsnark/algebra/fields/fp12_2over3over2.hpp b/src/snark/libsnark/algebra/fields/fp12_2over3over2.hpp
index 1de9d88..62ac8aa 100644
--- a/src/snark/libsnark/algebra/fields/fp12_2over3over2.hpp
+++ b/src/snark/libsnark/algebra/fields/fp12_2over3over2.hpp
@@ -66,7 +66,7 @@ public:
     Fp12_2over3over2_model squared_karatsuba() const;
     Fp12_2over3over2_model squared_complex() const;
     Fp12_2over3over2_model inverse() const;
-    Fp12_2over3over2_model Frobenius_map(unsigned long power) const;
+    Fp12_2over3over2_model Frobenius_map(uint64_t power) const;
     Fp12_2over3over2_model unitary_inverse() const;
     Fp12_2over3over2_model cyclotomic_squared() const;
 
diff --git a/src/snark/libsnark/algebra/fields/fp12_2over3over2.tcc b/src/snark/libsnark/algebra/fields/fp12_2over3over2.tcc
index 2fbc0b6..dda3f40 100644
--- a/src/snark/libsnark/algebra/fields/fp12_2over3over2.tcc
+++ b/src/snark/libsnark/algebra/fields/fp12_2over3over2.tcc
@@ -156,7 +156,7 @@ Fp12_2over3over2_model<n,modulus> Fp12_2over3over2_model<n,modulus>::inverse() c
 }
 
 template<mp_size_t n, const bigint<n>& modulus>
-Fp12_2over3over2_model<n,modulus> Fp12_2over3over2_model<n,modulus>::Frobenius_map(unsigned long power) const
+Fp12_2over3over2_model<n,modulus> Fp12_2over3over2_model<n,modulus>::Frobenius_map(uint64_t power) const
 {
     return Fp12_2over3over2_model<n,modulus>(c0.Frobenius_map(power),
                                              Frobenius_coeffs_c1[power % 12] * c1.Frobenius_map(power));
@@ -339,16 +339,16 @@ Fp12_2over3over2_model<n, modulus> Fp12_2over3over2_model<n,modulus>::cyclotomic
     Fp12_2over3over2_model<n,modulus> res = Fp12_2over3over2_model<n,modulus>::one();
 
     bool found_one = false;
-    for (long i = m-1; i >= 0; --i)
+    for (int64_t i = m-1; i >= 0; --i)
     {
-        for (long j = GMP_NUMB_BITS - 1; j >= 0; --j)
+        for (int64_t j = GMP_NUMB_BITS - 1; j >= 0; --j)
         {
             if (found_one)
             {
                 res = res.cyclotomic_squared();
             }
 
-            if (exponent.data[i] & (1ul<<j))
+            if (exponent.data[i] & (UINT64_C(1)<<j))
             {
                 found_one = true;
                 res = res * (*this);
diff --git a/src/snark/libsnark/algebra/fields/fp2.hpp b/src/snark/libsnark/algebra/fields/fp2.hpp
index f077269..276c923 100644
--- a/src/snark/libsnark/algebra/fields/fp2.hpp
+++ b/src/snark/libsnark/algebra/fields/fp2.hpp
@@ -66,7 +66,7 @@ public:
     Fp2_model operator-() const;
     Fp2_model squared() const; // default is squared_complex
     Fp2_model inverse() const;
-    Fp2_model Frobenius_map(unsigned long power) const;
+    Fp2_model Frobenius_map(uint64_t power) const;
     Fp2_model sqrt() const; // HAS TO BE A SQUARE (else does not terminate)
     Fp2_model squared_karatsuba() const;
     Fp2_model squared_complex() const;
diff --git a/src/snark/libsnark/algebra/fields/fp2.tcc b/src/snark/libsnark/algebra/fields/fp2.tcc
index 1632a04..fb3eacd 100644
--- a/src/snark/libsnark/algebra/fields/fp2.tcc
+++ b/src/snark/libsnark/algebra/fields/fp2.tcc
@@ -136,7 +136,7 @@ Fp2_model<n,modulus> Fp2_model<n,modulus>::inverse() const
 }
 
 template<mp_size_t n, const bigint<n>& modulus>
-Fp2_model<n,modulus> Fp2_model<n,modulus>::Frobenius_map(unsigned long power) const
+Fp2_model<n,modulus> Fp2_model<n,modulus>::Frobenius_map(uint64_t power) const
 {
     return Fp2_model<n,modulus>(c0,
                                 Frobenius_coeffs_c1[power % 2] * c1);
diff --git a/src/snark/libsnark/algebra/fields/fp6_3over2.hpp b/src/snark/libsnark/algebra/fields/fp6_3over2.hpp
index 335d61c..912c58a 100644
--- a/src/snark/libsnark/algebra/fields/fp6_3over2.hpp
+++ b/src/snark/libsnark/algebra/fields/fp6_3over2.hpp
@@ -63,7 +63,7 @@ public:
     Fp6_3over2_model operator-() const;
     Fp6_3over2_model squared() const;
     Fp6_3over2_model inverse() const;
-    Fp6_3over2_model Frobenius_map(unsigned long power) const;
+    Fp6_3over2_model Frobenius_map(uint64_t power) const;
 
     static my_Fp2 mul_by_non_residue(const my_Fp2 &elt);
 
diff --git a/src/snark/libsnark/algebra/fields/fp6_3over2.tcc b/src/snark/libsnark/algebra/fields/fp6_3over2.tcc
index f4fffde..86b864e 100644
--- a/src/snark/libsnark/algebra/fields/fp6_3over2.tcc
+++ b/src/snark/libsnark/algebra/fields/fp6_3over2.tcc
@@ -149,7 +149,7 @@ Fp6_3over2_model<n,modulus> Fp6_3over2_model<n,modulus>::inverse() const
 }
 
 template<mp_size_t n, const bigint<n>& modulus>
-Fp6_3over2_model<n,modulus> Fp6_3over2_model<n,modulus>::Frobenius_map(unsigned long power) const
+Fp6_3over2_model<n,modulus> Fp6_3over2_model<n,modulus>::Frobenius_map(uint64_t power) const
 {
     return Fp6_3over2_model<n,modulus>(c0.Frobenius_map(power),
                                        Frobenius_coeffs_c1[power % 6] * c1.Frobenius_map(power),
diff --git a/src/snark/libsnark/algebra/fields/tests/test_bigint.cpp b/src/snark/libsnark/algebra/fields/tests/test_bigint.cpp
index d2da59e..ac8c31a 100644
--- a/src/snark/libsnark/algebra/fields/tests/test_bigint.cpp
+++ b/src/snark/libsnark/algebra/fields/tests/test_bigint.cpp
@@ -13,7 +13,7 @@ using namespace libsnark;
 
 TEST(algebra, bigint)
 {
-    static_assert(ULONG_MAX == 0xFFFFFFFFFFFFFFFFul, "unsigned long not 64-bit");
+    static_assert(UINT64_MAX == 0xFFFFFFFFFFFFFFFFul, "uint64_t not 64-bit");
     static_assert(GMP_NUMB_BITS == 64, "GMP limb not 64-bit");
 
     const char *b1_decimal = "76749407";
@@ -22,15 +22,15 @@ TEST(algebra, bigint)
     const char *b2_binary = "0000000000000000000000000000010101111101101000000110100001011010"
                             "1101101010001001000001101000101000100110011001110001111110100010";
 
-    bigint<1> b0 = bigint<1>(0ul);
+    bigint<1> b0 = bigint<1>(UINT64_C(0));
     bigint<1> b1 = bigint<1>(b1_decimal);
     bigint<2> b2 = bigint<2>(b2_decimal);
 
-    EXPECT_EQ(b0.as_ulong(), 0ul);
+    EXPECT_EQ(b0.as_ulong(), UINT64_C(0));
     EXPECT_TRUE(b0.is_zero());
-    EXPECT_EQ(b1.as_ulong(), 76749407ul);
+    EXPECT_EQ(b1.as_ulong(), UINT64_C(76749407));
     EXPECT_FALSE(b1.is_zero());
-    EXPECT_EQ(b2.as_ulong(), 15747124762497195938ul);
+    EXPECT_EQ(b2.as_ulong(), UINT64_C(15747124762497195938));
     EXPECT_FALSE(b2.is_zero());
     EXPECT_NE(b0, b1);
     EXPECT_FALSE(b0 == b1);
diff --git a/src/snark/libsnark/algebra/scalar_multiplication/multiexp.tcc b/src/snark/libsnark/algebra/scalar_multiplication/multiexp.tcc
index a6b14c4..e1783a8 100644
--- a/src/snark/libsnark/algebra/scalar_multiplication/multiexp.tcc
+++ b/src/snark/libsnark/algebra/scalar_multiplication/multiexp.tcc
@@ -40,7 +40,7 @@ public:
 #if defined(__x86_64__) && defined(USE_ASM)
         if (n == 3)
         {
-            long res;
+            int64_t res;
             __asm__
                 ("// check for overflow           \n\t"
                  "mov $0, %[res]                  \n\t"
@@ -58,7 +58,7 @@ public:
         }
         else if (n == 4)
         {
-            long res;
+            int64_t res;
             __asm__
                 ("// check for overflow           \n\t"
                  "mov $0, %[res]                  \n\t"
@@ -77,7 +77,7 @@ public:
         }
         else if (n == 5)
         {
-            long res;
+            int64_t res;
             __asm__
                 ("// check for overflow           \n\t"
                  "mov $0, %[res]                  \n\t"
@@ -190,7 +190,7 @@ T multi_exp_inner(typename std::vector<T>::const_iterator vec_start,
     if (vec_len != odd_vec_len)
     {
         g.emplace_back(T::zero());
-        opt_q.emplace_back(ordered_exponent<n>(odd_vec_len - 1, bigint<n>(0ul)));
+        opt_q.emplace_back(ordered_exponent<n>(odd_vec_len - 1, bigint<n>(UINT64_C(0))));
     }
     assert(g.size() % 2 == 1);
     assert(opt_q.size() == g.size());
@@ -214,7 +214,7 @@ T multi_exp_inner(typename std::vector<T>::const_iterator vec_start,
         const size_t bbits = b.r.num_bits();
         const size_t limit = (abits-bbits >= 20 ? 20 : abits-bbits);
 
-        if (bbits < 1ul<<limit)
+        if (bbits < UINT64_C(1)<<limit)
         {
             /*
               In this case, exponentiating to the power of a is cheaper than
@@ -389,7 +389,7 @@ size_t get_exp_window_size(const size_t num_scalars)
 #endif
     }
     size_t window = 1;
-    for (long i = T::fixed_base_exp_window_table.size()-1; i >= 0; --i)
+    for (int64_t i = T::fixed_base_exp_window_table.size()-1; i >= 0; --i)
     {
 #ifdef DEBUG
         if (!inhibit_profiling_info)
@@ -420,9 +420,9 @@ window_table<T> get_window_table(const size_t scalar_size,
                                  const size_t window,
                                  const T &g)
 {
-    const size_t in_window = 1ul<<window;
+    const size_t in_window = UINT64_C(1)<<window;
     const size_t outerc = (scalar_size+window-1)/window;
-    const size_t last_in_window = 1ul<<(scalar_size - (outerc-1)*window);
+    const size_t last_in_window = UINT64_C(1)<<(scalar_size - (outerc-1)*window);
 #ifdef DEBUG
     if (!inhibit_profiling_info)
     {
diff --git a/src/snark/libsnark/algebra/scalar_multiplication/wnaf.hpp b/src/snark/libsnark/algebra/scalar_multiplication/wnaf.hpp
index a7ecd59..d6c4326 100644
--- a/src/snark/libsnark/algebra/scalar_multiplication/wnaf.hpp
+++ b/src/snark/libsnark/algebra/scalar_multiplication/wnaf.hpp
@@ -18,7 +18,7 @@ namespace libsnark {
  * Find the wNAF representation of the given scalar relative to the given window size.
  */
 template<mp_size_t n>
-std::vector<long> find_wnaf(const size_t window_size, const bigint<n> &scalar);
+std::vector<int64_t> find_wnaf(const size_t window_size, const bigint<n> &scalar);
 
 /**
  * In additive notation, use wNAF exponentiation (with the given window size) to compute scalar * base.
diff --git a/src/snark/libsnark/algebra/scalar_multiplication/wnaf.tcc b/src/snark/libsnark/algebra/scalar_multiplication/wnaf.tcc
index a5e47e8..4f2e407 100644
--- a/src/snark/libsnark/algebra/scalar_multiplication/wnaf.tcc
+++ b/src/snark/libsnark/algebra/scalar_multiplication/wnaf.tcc
@@ -17,15 +17,15 @@
 namespace libsnark {
 
 template<mp_size_t n>
-std::vector<long> find_wnaf(const size_t window_size, const bigint<n> &scalar)
+std::vector<int64_t> find_wnaf(const size_t window_size, const bigint<n> &scalar)
 {
     const size_t length = scalar.max_bits(); // upper bound
-    std::vector<long> res(length+1);
+    std::vector<int64_t> res(length+1);
     bigint<n> c = scalar;
-    long j = 0;
+    int64_t j = 0;
     while (!c.is_zero())
     {
-        long u;
+        int64_t u;
         if ((c.data[0] & 1) == 1)
         {
             u = c.data[0] % (1u << (window_size+1));
@@ -59,11 +59,11 @@ std::vector<long> find_wnaf(const size_t window_size, const bigint<n> &scalar)
 template<typename T, mp_size_t n>
 T fixed_window_wnaf_exp(const size_t window_size, const T &base, const bigint<n> &scalar)
 {
-    std::vector<long> naf = find_wnaf(window_size, scalar);
-    std::vector<T> table(1ul<<(window_size-1));
+    std::vector<int64_t> naf = find_wnaf(window_size, scalar);
+    std::vector<T> table(UINT64_C(1)<<(window_size-1));
     T tmp = base;
     T dbl = base.dbl();
-    for (size_t i = 0; i < 1ul<<(window_size-1); ++i)
+    for (size_t i = 0; i < UINT64_C(1)<<(window_size-1); ++i)
     {
         table[i] = tmp;
         tmp = tmp + dbl;
@@ -71,7 +71,7 @@ T fixed_window_wnaf_exp(const size_t window_size, const T &base, const bigint<n>
 
     T res = T::zero();
     bool found_nonzero = false;
-    for (long i = naf.size()-1; i >= 0; --i)
+    for (int64_t i = naf.size()-1; i >= 0; --i)
     {
         if (found_nonzero)
         {
@@ -99,7 +99,7 @@ template<typename T, mp_size_t n>
 T opt_window_wnaf_exp(const T &base, const bigint<n> &scalar, const size_t scalar_bits)
 {
     size_t best = 0;
-    for (long i = T::wnaf_window_table.size() - 1; i >= 0; --i)
+    for (int64_t i = T::wnaf_window_table.size() - 1; i >= 0; --i)
     {
         if (scalar_bits >= T::wnaf_window_table[i])
         {
diff --git a/src/snark/libsnark/common/data_structures/merkle_tree.tcc b/src/snark/libsnark/common/data_structures/merkle_tree.tcc
index 281700b..ce28b12 100644
--- a/src/snark/libsnark/common/data_structures/merkle_tree.tcc
+++ b/src/snark/libsnark/common/data_structures/merkle_tree.tcc
@@ -66,14 +66,14 @@ merkle_tree<HashT>::merkle_tree(const size_t depth,
     assert(log2(contents_as_vector.size()) <= depth);
     for (size_t address = 0; address < contents_as_vector.size(); ++address)
     {
-        const size_t idx = address + (1ul<<depth) - 1;
+        const size_t idx = address + (UINT64_C(1)<<depth) - 1;
         values[idx] = contents_as_vector[address];
         hashes[idx] = contents_as_vector[address];
         hashes[idx].resize(digest_size);
     }
 
-    size_t idx_begin = (1ul<<depth) - 1;
-    size_t idx_end = contents_as_vector.size() + ((1ul<<depth) - 1);
+    size_t idx_begin = (UINT64_C(1)<<depth) - 1;
+    size_t idx_end = contents_as_vector.size() + ((UINT64_C(1)<<depth) - 1);
 
     for (int layer = depth; layer > 0; --layer)
     {
@@ -100,13 +100,13 @@ merkle_tree<HashT>::merkle_tree(const size_t depth,
 
     if (!contents.empty())
     {
-        assert(contents.rbegin()->first < 1ul<<depth);
+        assert(contents.rbegin()->first < UINT64_C(1)<<depth);
 
         for (auto it = contents.begin(); it != contents.end(); ++it)
         {
             const size_t address = it->first;
             const bit_vector value = it->second;
-            const size_t idx = address + (1ul<<depth) - 1;
+            const size_t idx = address + (UINT64_C(1)<<depth) - 1;
 
             values[address] = value;
             hashes[idx] = value;
@@ -167,7 +167,7 @@ void merkle_tree<HashT>::set_value(const size_t address,
                                    const bit_vector &value)
 {
     assert(log2(address) <= depth);
-    size_t idx = address + (1ul<<depth) - 1;
+    size_t idx = address + (UINT64_C(1)<<depth) - 1;
 
     assert(value.size() == value_size);
     values[address] = value;
@@ -201,7 +201,7 @@ typename HashT::merkle_authentication_path_type merkle_tree<HashT>::get_path(con
 {
     typename HashT::merkle_authentication_path_type result(depth);
     assert(log2(address) <= depth);
-    size_t idx = address + (1ul<<depth) - 1;
+    size_t idx = address + (UINT64_C(1)<<depth) - 1;
 
     for (size_t layer = depth; layer > 0; --layer)
     {
@@ -209,7 +209,7 @@ typename HashT::merkle_authentication_path_type merkle_tree<HashT>::get_path(con
         auto it = hashes.find(sibling_idx);
         if (layer == depth)
         {
-            auto it2 = values.find(sibling_idx - ((1ul<<depth) - 1));
+            auto it2 = values.find(sibling_idx - ((UINT64_C(1)<<depth) - 1));
             result[layer-1] = (it2 == values.end() ? bit_vector(value_size, false) : it2->second);
             result[layer-1].resize(digest_size);
         }
@@ -227,7 +227,7 @@ typename HashT::merkle_authentication_path_type merkle_tree<HashT>::get_path(con
 template<typename HashT>
 void merkle_tree<HashT>::dump() const
 {
-    for (size_t i = 0; i < 1ul<<depth; ++i)
+    for (size_t i = 0; i < UINT64_C(1)<<depth; ++i)
     {
         auto it = values.find(i);
         printf("[%zu] -> ", i);
diff --git a/src/snark/libsnark/common/profiling.cpp b/src/snark/libsnark/common/profiling.cpp
index 8fc3e6f..44781e1 100644
--- a/src/snark/libsnark/common/profiling.cpp
+++ b/src/snark/libsnark/common/profiling.cpp
@@ -28,14 +28,14 @@
 
 namespace libsnark {
 
-long long get_nsec_time()
+int64_t get_nsec_time()
 {
     auto timepoint = std::chrono::high_resolution_clock::now();
     return std::chrono::duration_cast<std::chrono::nanoseconds>(timepoint.time_since_epoch()).count();
 }
 
 /* Return total CPU time consumed by all threads of the process, in nanoseconds. */
-long long get_nsec_cpu_time()
+int64_t get_nsec_cpu_time()
 {
     ::timespec ts;
     if ( ::clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts) )
@@ -45,10 +45,10 @@ long long get_nsec_cpu_time()
     return ts.tv_sec * 1000000000ll + ts.tv_nsec;
 }
 
-static long long start_time;
-static long long last_time;
-static long long start_cpu_time;
-static long long last_cpu_time;
+static int64_t start_time;
+static int64_t last_time;
+static int64_t start_cpu_time;
+static int64_t last_cpu_time;
 
 void start_profiling()
 {
@@ -59,20 +59,20 @@ void start_profiling()
 }
 
 std::map<std::string, size_t> invocation_counts;
-static std::map<std::string, long long> enter_times;
-std::map<std::string, long long> last_times;
-std::map<std::string, long long> cumulative_times;
+static std::map<std::string, int64_t> enter_times;
+std::map<std::string, int64_t> last_times;
+std::map<std::string, int64_t> cumulative_times;
 //TODO: Instead of analogous maps for time and cpu_time, use a single struct-valued map
-static std::map<std::string, long long> enter_cpu_times;
-static std::map<std::string, long long> last_cpu_times;
-static std::map<std::pair<std::string, std::string>, long long> op_counts;
-static std::map<std::pair<std::string, std::string>, long long> cumulative_op_counts; // ((msg, data_point), value)
+static std::map<std::string, int64_t> enter_cpu_times;
+static std::map<std::string, int64_t> last_cpu_times;
+static std::map<std::pair<std::string, std::string>, int64_t> op_counts;
+static std::map<std::pair<std::string, std::string>, int64_t> cumulative_op_counts; // ((msg, data_point), value)
     // TODO: Convert op_counts and cumulative_op_counts from pair to structs
 static size_t indentation = 0;
 
 static std::vector<std::string> block_names;
 
-static std::list<std::pair<std::string, long long*> > op_data_points = {
+static std::list<std::pair<std::string, int64_t*> > op_data_points = {
 #ifdef PROFILE_OP_COUNTS
     std::make_pair("Fradd", &Fr<default_ec_pp>::add_cnt),
     std::make_pair("Frsub", &Fr<default_ec_pp>::sub_cnt),
@@ -100,7 +100,7 @@ void clear_profiling_counters()
     cumulative_times.clear();
 }
 
-void print_cumulative_time_entry(const std::string &key, const long long factor)
+void print_cumulative_time_entry(const std::string &key, const int64_t factor)
 {
     const double total_ms = (cumulative_times.at(key) * 1e-6);
     const size_t cnt = invocation_counts.at(key);
@@ -108,7 +108,7 @@ void print_cumulative_time_entry(const std::string &key, const long long factor)
     printf("   %-45s: %12.5fms = %lld * %0.5fms (%zu invocations, %0.5fms = %lld * %0.5fms per invocation)\n", key.c_str(), total_ms, factor, total_ms/factor, cnt, avg_ms, factor, avg_ms/factor);
 }
 
-void print_cumulative_times(const long long factor)
+void print_cumulative_times(const int64_t factor)
 {
     printf("Dumping times:\n");
     for (auto& kv : cumulative_times)
@@ -157,7 +157,7 @@ void print_op_profiling(const std::string &msg)
 
     printf("(opcounts) = (");
     bool first = true;
-    for (std::pair<std::string, long long*> p : op_data_points)
+    for (std::pair<std::string, int64_t*> p : op_data_points)
     {
         if (!first)
         {
@@ -173,14 +173,14 @@ void print_op_profiling(const std::string &msg)
 #endif
 }
 
-static void print_times_from_last_and_start(long long     now, long long     last,
-                                            long long cpu_now, long long cpu_last)
+static void print_times_from_last_and_start(int64_t     now, int64_t     last,
+                                            int64_t cpu_now, int64_t cpu_last)
 {
-    long long time_from_start = now - start_time;
-    long long time_from_last = now - last;
+    int64_t time_from_start = now - start_time;
+    int64_t time_from_last = now - last;
 
-    long long cpu_time_from_start = cpu_now - start_cpu_time;
-    long long cpu_time_from_last = cpu_now - cpu_last;
+    int64_t cpu_time_from_start = cpu_now - start_cpu_time;
+    int64_t cpu_time_from_last = cpu_now - cpu_last;
 
     if (time_from_last != 0) {
         double parallelism_from_last = 1.0 * cpu_time_from_last / time_from_last;
@@ -201,8 +201,8 @@ void print_time(const char* msg)
         return;
     }
 
-    long long now = get_nsec_time();
-    long long cpu_now = get_nsec_cpu_time();
+    int64_t now = get_nsec_time();
+    int64_t cpu_now = get_nsec_cpu_time();
 
     printf("%-35s\t", msg);
     print_times_from_last_and_start(now, last_time, cpu_now, last_cpu_time);
@@ -233,7 +233,7 @@ void print_indent()
 
 void op_profiling_enter(const std::string &msg)
 {
-    for (std::pair<std::string, long long*> p : op_data_points)
+    for (std::pair<std::string, int64_t*> p : op_data_points)
     {
         op_counts[std::make_pair(msg, p.first)] = *(p.second);
     }
@@ -247,9 +247,9 @@ void enter_block(const std::string &msg, const bool indent)
     }
 
     block_names.emplace_back(msg);
-    long long t = get_nsec_time();
+    int64_t t = get_nsec_time();
     enter_times[msg] = t;
-    long long cpu_t = get_nsec_cpu_time();
+    int64_t cpu_t = get_nsec_cpu_time();
     enter_cpu_times[msg] = cpu_t;
 
     if (inhibit_profiling_info)
@@ -290,15 +290,15 @@ void leave_block(const std::string &msg, const bool indent)
 
     ++invocation_counts[msg];
 
-    long long t = get_nsec_time();
+    int64_t t = get_nsec_time();
     last_times[msg] = (t - enter_times[msg]);
     cumulative_times[msg] += (t - enter_times[msg]);
 
-    long long cpu_t = get_nsec_cpu_time();
+    int64_t cpu_t = get_nsec_cpu_time();
     last_cpu_times[msg] = (cpu_t - enter_cpu_times[msg]);
 
 #ifdef PROFILE_OP_COUNTS
-    for (std::pair<std::string, long long*> p : op_data_points)
+    for (std::pair<std::string, int64_t*> p : op_data_points)
     {
         cumulative_op_counts[std::make_pair(msg, p.first)] += *(p.second)-op_counts[std::make_pair(msg, p.first)];
     }
diff --git a/src/snark/libsnark/common/profiling.hpp b/src/snark/libsnark/common/profiling.hpp
index 9619117..4a49610 100644
--- a/src/snark/libsnark/common/profiling.hpp
+++ b/src/snark/libsnark/common/profiling.hpp
@@ -22,7 +22,7 @@
 namespace libsnark {
 
 void start_profiling();
-long long get_nsec_time();
+int64_t get_nsec_time();
 void print_time(const char* msg);
 void print_header(const char* msg);
 
@@ -31,13 +31,13 @@ void print_indent();
 extern bool inhibit_profiling_info;
 extern bool inhibit_profiling_counters;
 extern std::map<std::string, size_t> invocation_counts;
-extern std::map<std::string, long long> last_times;
-extern std::map<std::string, long long> cumulative_times;
+extern std::map<std::string, int64_t> last_times;
+extern std::map<std::string, int64_t> cumulative_times;
 
 void clear_profiling_counters();
 
-void print_cumulative_time_entry(const std::string &key, const long long factor=1);
-void print_cumulative_times(const long long factor=1);
+void print_cumulative_time_entry(const std::string &key, const int64_t factor=1);
+void print_cumulative_times(const int64_t factor=1);
 void print_cumulative_op_counts(const bool only_fq=false);
 
 void enter_block(const std::string &msg, const bool indent=true);
diff --git a/src/snark/libsnark/common/utils.cpp b/src/snark/libsnark/common/utils.cpp
index dd114fd..06af6ef 100644
--- a/src/snark/libsnark/common/utils.cpp
+++ b/src/snark/libsnark/common/utils.cpp
@@ -16,7 +16,7 @@
 namespace libsnark {
 
 size_t log2(size_t n)
-/* returns ceil(log2(n)), so 1ul<<log2(n) is the smallest power of 2,
+/* returns ceil(log2(n)), so UINT64_C(1)<<log2(n) is the smallest power of 2,
    that is not less than n. */
 {
     size_t r = ((n & (n-1)) == 0 ? 0 : 1); // add 1 if n is not power of 2
@@ -41,20 +41,20 @@ size_t bitreverse(size_t n, const size_t l)
     return r;
 }
 
-bit_vector int_list_to_bits(const std::initializer_list<unsigned long> &l, const size_t wordsize)
+bit_vector int_list_to_bits(const std::initializer_list<uint64_t> &l, const size_t wordsize)
 {
     bit_vector res(wordsize*l.size());
     for (size_t i = 0; i < l.size(); ++i)
     {
         for (size_t j = 0; j < wordsize; ++j)
         {
-            res[i*wordsize + j] = (*(l.begin()+i) & (1ul<<(wordsize-1-j)));
+            res[i*wordsize + j] = (*(l.begin()+i) & (UINT64_C(1)<<(wordsize-1-j)));
         }
     }
     return res;
 }
 
-long long div_ceil(long long x, long long y)
+int64_t div_ceil(int64_t x, int64_t y)
 {
     return (x + (y-1)) / y;
 }
diff --git a/src/snark/libsnark/common/utils.hpp b/src/snark/libsnark/common/utils.hpp
index d7d9e89..505f674 100644
--- a/src/snark/libsnark/common/utils.hpp
+++ b/src/snark/libsnark/common/utils.hpp
@@ -20,14 +20,14 @@ namespace libsnark {
 
 typedef std::vector<bool> bit_vector;
 
-/// returns ceil(log2(n)), so 1ul<<log2(n) is the smallest power of 2, that is not less than n
+/// returns ceil(log2(n)), so UINT64_C(1)<<log2(n) is the smallest power of 2, that is not less than n
 size_t log2(size_t n);
 
-inline size_t exp2(size_t k) { return 1ul << k; }
+inline size_t exp2(size_t k) { return UINT64_C(1) << k; }
 
 size_t bitreverse(size_t n, const size_t l);
-bit_vector int_list_to_bits(const std::initializer_list<unsigned long> &l, const size_t wordsize);
-long long div_ceil(long long x, long long y);
+bit_vector int_list_to_bits(const std::initializer_list<uint64_t> &l, const size_t wordsize);
+int64_t div_ceil(int64_t x, int64_t y);
 
 bool is_little_endian();
 
diff --git a/src/snark/libsnark/gadgetlib1/gadgets/basic_gadgets.tcc b/src/snark/libsnark/gadgetlib1/gadgets/basic_gadgets.tcc
index 213b190..bcd2f2c 100644
--- a/src/snark/libsnark/gadgetlib1/gadgets/basic_gadgets.tcc
+++ b/src/snark/libsnark/gadgetlib1/gadgets/basic_gadgets.tcc
@@ -275,11 +275,11 @@ void test_disjunction_gadget(const size_t n)
     disjunction_gadget<FieldT> d(pb, inputs, output, "d");
     d.generate_r1cs_constraints();
 
-    for (size_t w = 0; w < 1ul<<n; ++w)
+    for (size_t w = 0; w < UINT64_C(1)<<n; ++w)
     {
         for (size_t j = 0; j < n; ++j)
         {
-            pb.val(inputs[j]) = FieldT((w & (1ul<<j)) ? 1 : 0);
+            pb.val(inputs[j]) = FieldT((w & (UINT64_C(1)<<j)) ? 1 : 0);
         }
 
         d.generate_r1cs_witness();
@@ -366,11 +366,11 @@ void test_conjunction_gadget(const size_t n)
     conjunction_gadget<FieldT> c(pb, inputs, output, "c");
     c.generate_r1cs_constraints();
 
-    for (size_t w = 0; w < 1ul<<n; ++w)
+    for (size_t w = 0; w < UINT64_C(1)<<n; ++w)
     {
         for (size_t j = 0; j < n; ++j)
         {
-            pb.val(inputs[j]) = (w & (1ul<<j)) ? FieldT::one() : FieldT::zero();
+            pb.val(inputs[j]) = (w & (UINT64_C(1)<<j)) ? FieldT::one() : FieldT::zero();
         }
 
         c.generate_r1cs_witness();
@@ -378,13 +378,13 @@ void test_conjunction_gadget(const size_t n)
 #ifdef DEBUG
         printf("positive test for %zu\n", w);
 #endif
-        assert(pb.val(output) == (w == (1ul<<n) - 1 ? FieldT::one() : FieldT::zero()));
+        assert(pb.val(output) == (w == (UINT64_C(1)<<n) - 1 ? FieldT::one() : FieldT::zero()));
         assert(pb.is_satisfied());
 
 #ifdef DEBUG
         printf("negative test for %zu\n", w);
 #endif
-        pb.val(output) = (w == (1ul<<n) - 1 ? FieldT::zero() : FieldT::one());
+        pb.val(output) = (w == (UINT64_C(1)<<n) - 1 ? FieldT::zero() : FieldT::one());
         assert(!pb.is_satisfied());
     }
 
@@ -454,9 +454,9 @@ void test_comparison_gadget(const size_t n)
     comparison_gadget<FieldT> cmp(pb, n, A, B, less, less_or_eq, "cmp");
     cmp.generate_r1cs_constraints();
 
-    for (size_t a = 0; a < 1ul<<n; ++a)
+    for (size_t a = 0; a < UINT64_C(1)<<n; ++a)
     {
-        for (size_t b = 0; b < 1ul<<n; ++b)
+        for (size_t b = 0; b < UINT64_C(1)<<n; ++b)
         {
             pb.val(A) = FieldT(a);
             pb.val(B) = FieldT(b);
@@ -523,16 +523,16 @@ void test_inner_product_gadget(const size_t n)
     inner_product_gadget<FieldT> g(pb, A, B, result, "g");
     g.generate_r1cs_constraints();
 
-    for (size_t i = 0; i < 1ul<<n; ++i)
+    for (size_t i = 0; i < UINT64_C(1)<<n; ++i)
     {
-        for (size_t j = 0; j < 1ul<<n; ++j)
+        for (size_t j = 0; j < UINT64_C(1)<<n; ++j)
         {
             size_t correct = 0;
             for (size_t k = 0; k < n; ++k)
             {
-                pb.val(A[k]) = (i & (1ul<<k) ? FieldT::one() : FieldT::zero());
-                pb.val(B[k]) = (j & (1ul<<k) ? FieldT::one() : FieldT::zero());
-                correct += ((i & (1ul<<k)) && (j & (1ul<<k)) ? 1 : 0);
+                pb.val(A[k]) = (i & (UINT64_C(1)<<k) ? FieldT::one() : FieldT::zero());
+                pb.val(B[k]) = (j & (UINT64_C(1)<<k) ? FieldT::one() : FieldT::zero());
+                correct += ((i & (UINT64_C(1)<<k)) && (j & (UINT64_C(1)<<k)) ? 1 : 0);
             }
 
             g.generate_r1cs_witness();
@@ -587,7 +587,7 @@ void loose_multiplexing_gadget<FieldT>::generate_r1cs_witness()
 {
     /* assumes that idx can be fit in ulong; true for our purposes for now */
     const bigint<FieldT::num_limbs> valint = this->pb.val(index).as_bigint();
-    unsigned long idx = valint.as_ulong();
+    uint64_t idx = valint.as_ulong();
     const bigint<FieldT::num_limbs> arrsize(arr.size());
 
     if (idx >= arr.size() || mpn_cmp(valint.data, arrsize.data, FieldT::num_limbs) >= 0)
@@ -619,7 +619,7 @@ void test_loose_multiplexing_gadget(const size_t n)
     protoboard<FieldT> pb;
 
     pb_variable_array<FieldT> arr;
-    arr.allocate(pb, 1ul<<n, "arr");
+    arr.allocate(pb, UINT64_C(1)<<n, "arr");
     pb_variable<FieldT> index, result, success_flag;
     index.allocate(pb, "index");
     result.allocate(pb, "result");
@@ -628,20 +628,20 @@ void test_loose_multiplexing_gadget(const size_t n)
     loose_multiplexing_gadget<FieldT> g(pb, arr, index, result, success_flag, "g");
     g.generate_r1cs_constraints();
 
-    for (size_t i = 0; i < 1ul<<n; ++i)
+    for (size_t i = 0; i < UINT64_C(1)<<n; ++i)
     {
-        pb.val(arr[i]) = FieldT((19*i) % (1ul<<n));
+        pb.val(arr[i]) = FieldT((19*i) % (UINT64_C(1)<<n));
     }
 
-    for (int idx = -1; idx <= (int)(1ul<<n); ++idx)
+    for (int idx = -1; idx <= (int)(UINT64_C(1)<<n); ++idx)
     {
         pb.val(index) = FieldT(idx);
         g.generate_r1cs_witness();
 
-        if (0 <= idx && idx <= (int)(1ul<<n) - 1)
+        if (0 <= idx && idx <= (int)(UINT64_C(1)<<n) - 1)
         {
             printf("demuxing element %d (in bounds)\n", idx);
-            assert(pb.val(result) == FieldT((19*idx) % (1ul<<n)));
+            assert(pb.val(result) == FieldT((19*idx) % (UINT64_C(1)<<n)));
             assert(pb.val(success_flag) == FieldT::one());
             assert(pb.is_satisfied());
             pb.val(result) -= FieldT::one();
diff --git a/src/snark/libsnark/gadgetlib1/gadgets/hashes/sha256/sha256_aux.tcc b/src/snark/libsnark/gadgetlib1/gadgets/hashes/sha256/sha256_aux.tcc
index 8ab67be..148fe79 100644
--- a/src/snark/libsnark/gadgetlib1/gadgets/hashes/sha256/sha256_aux.tcc
+++ b/src/snark/libsnark/gadgetlib1/gadgets/hashes/sha256/sha256_aux.tcc
@@ -285,7 +285,7 @@ void majority_gadget<FieldT>::generate_r1cs_witness()
 {
     for (size_t i = 0; i < 32; ++i)
     {
-        const long v = (this->pb.lc_val(X[i]) + this->pb.lc_val(Y[i]) + this->pb.lc_val(Z[i])).as_ulong();
+        const int64_t v = (this->pb.lc_val(X[i]) + this->pb.lc_val(Y[i]) + this->pb.lc_val(Z[i])).as_ulong();
         this->pb.val(result_bits[i]) = FieldT(v / 2);
     }
 
diff --git a/src/snark/libsnark/gadgetlib1/gadgets/hashes/sha256/sha256_components.hpp b/src/snark/libsnark/gadgetlib1/gadgets/hashes/sha256/sha256_components.hpp
index c2f31e3..13bbc07 100644
--- a/src/snark/libsnark/gadgetlib1/gadgets/hashes/sha256/sha256_components.hpp
+++ b/src/snark/libsnark/gadgetlib1/gadgets/hashes/sha256/sha256_components.hpp
@@ -78,7 +78,7 @@ public:
     pb_linear_combination_array<FieldT> g;
     pb_linear_combination_array<FieldT> h;
     pb_variable<FieldT> W;
-    long K;
+    int64_t K;
     pb_linear_combination_array<FieldT> new_a;
     pb_linear_combination_array<FieldT> new_e;
 
@@ -92,7 +92,7 @@ public:
                                  const pb_linear_combination_array<FieldT> &g,
                                  const pb_linear_combination_array<FieldT> &h,
                                  const pb_variable<FieldT> &W,
-                                 const long &K,
+                                 const int64_t &K,
                                  const pb_linear_combination_array<FieldT> &new_a,
                                  const pb_linear_combination_array<FieldT> &new_e,
                                  const std::string &annotation_prefix);
diff --git a/src/snark/libsnark/gadgetlib1/gadgets/hashes/sha256/sha256_components.tcc b/src/snark/libsnark/gadgetlib1/gadgets/hashes/sha256/sha256_components.tcc
index e8f233a..b0e0063 100644
--- a/src/snark/libsnark/gadgetlib1/gadgets/hashes/sha256/sha256_components.tcc
+++ b/src/snark/libsnark/gadgetlib1/gadgets/hashes/sha256/sha256_components.tcc
@@ -16,7 +16,7 @@
 
 namespace libsnark {
 
-const unsigned long SHA256_K[64] =  {
+const uint64_t SHA256_K[64] =  {
     0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
@@ -27,7 +27,7 @@ const unsigned long SHA256_K[64] =  {
     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
 };
 
-const unsigned long SHA256_H[8] = {
+const uint64_t SHA256_H[8] = {
     0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
 };
 
@@ -149,7 +149,7 @@ sha256_round_function_gadget<FieldT>::sha256_round_function_gadget(protoboard<Fi
                                                                    const pb_linear_combination_array<FieldT> &g,
                                                                    const pb_linear_combination_array<FieldT> &h,
                                                                    const pb_variable<FieldT> &W,
-                                                                   const long &K,
+                                                                   const int64_t &K,
                                                                    const pb_linear_combination_array<FieldT> &new_a,
                                                                    const pb_linear_combination_array<FieldT> &new_e,
                                                                    const std::string &annotation_prefix) :
diff --git a/src/snark/libsnark/gadgetlib1/gadgets/merkle_tree/merkle_authentication_path_variable.tcc b/src/snark/libsnark/gadgetlib1/gadgets/merkle_tree/merkle_authentication_path_variable.tcc
index d773051..b3d805d 100644
--- a/src/snark/libsnark/gadgetlib1/gadgets/merkle_tree/merkle_authentication_path_variable.tcc
+++ b/src/snark/libsnark/gadgetlib1/gadgets/merkle_tree/merkle_authentication_path_variable.tcc
@@ -41,7 +41,7 @@ void merkle_authentication_path_variable<FieldT, HashT>::generate_r1cs_witness(c
 
     for (size_t i = 0; i < tree_depth; ++i)
     {
-        if (address & (1ul << (tree_depth-1-i)))
+        if (address & (UINT64_C(1) << (tree_depth-1-i)))
         {
             left_digests[i].generate_r1cs_witness(path[i]);
         }
@@ -58,7 +58,7 @@ merkle_authentication_path merkle_authentication_path_variable<FieldT, HashT>::g
     merkle_authentication_path result;
     for (size_t i = 0; i < tree_depth; ++i)
     {
-        if (address & (1ul << (tree_depth-1-i)))
+        if (address & (UINT64_C(1) << (tree_depth-1-i)))
         {
             result.emplace_back(left_digests[i].get_digest());
         }
diff --git a/src/snark/libsnark/gadgetlib1/gadgets/merkle_tree/merkle_tree_check_read_gadget.tcc b/src/snark/libsnark/gadgetlib1/gadgets/merkle_tree/merkle_tree_check_read_gadget.tcc
index 6002a58..2fde4f6 100644
--- a/src/snark/libsnark/gadgetlib1/gadgets/merkle_tree/merkle_tree_check_read_gadget.tcc
+++ b/src/snark/libsnark/gadgetlib1/gadgets/merkle_tree/merkle_tree_check_read_gadget.tcc
@@ -144,10 +144,10 @@ void test_merkle_tree_check_read_gadget()
     bit_vector address_bits;
 
     size_t address = 0;
-    for (long level = tree_depth-1; level >= 0; --level)
+    for (int64_t level = tree_depth-1; level >= 0; --level)
     {
         const bool computed_is_right = (std::rand() % 2);
-        address |= (computed_is_right ? 1ul << (tree_depth-1-level) : 0);
+        address |= (computed_is_right ? UINT64_C(1) << (tree_depth-1-level) : 0);
         address_bits.push_back(computed_is_right);
         bit_vector other(digest_len);
         std::generate(other.begin(), other.end(), [&]() { return std::rand() % 2; });
diff --git a/src/snark/libsnark/gadgetlib1/gadgets/merkle_tree/merkle_tree_check_update_gadget.tcc b/src/snark/libsnark/gadgetlib1/gadgets/merkle_tree/merkle_tree_check_update_gadget.tcc
index 1ac08ed..3e73904 100644
--- a/src/snark/libsnark/gadgetlib1/gadgets/merkle_tree/merkle_tree_check_update_gadget.tcc
+++ b/src/snark/libsnark/gadgetlib1/gadgets/merkle_tree/merkle_tree_check_update_gadget.tcc
@@ -197,10 +197,10 @@ void test_merkle_tree_check_update_gadget()
     bit_vector address_bits;
 
     size_t address = 0;
-    for (long level = tree_depth-1; level >= 0; --level)
+    for (int64_t level = tree_depth-1; level >= 0; --level)
     {
         const bool computed_is_right = (std::rand() % 2);
-        address |= (computed_is_right ? 1ul << (tree_depth-1-level) : 0);
+        address |= (computed_is_right ? UINT64_C(1) << (tree_depth-1-level) : 0);
         address_bits.push_back(computed_is_right);
         bit_vector other(digest_len);
         std::generate(other.begin(), other.end(), [&]() { return std::rand() % 2; });
diff --git a/src/snark/libsnark/gadgetlib1/pb_variable.hpp b/src/snark/libsnark/gadgetlib1/pb_variable.hpp
index fdf64d0..a6c7174 100644
--- a/src/snark/libsnark/gadgetlib1/pb_variable.hpp
+++ b/src/snark/libsnark/gadgetlib1/pb_variable.hpp
@@ -59,7 +59,7 @@ public:
 
     void fill_with_field_elements(protoboard<FieldT> &pb, const std::vector<FieldT>& vals) const;
     void fill_with_bits(protoboard<FieldT> &pb, const bit_vector& bits) const;
-    void fill_with_bits_of_ulong(protoboard<FieldT> &pb, const unsigned long i) const;
+    void fill_with_bits_of_ulong(protoboard<FieldT> &pb, const uint64_t i) const;
     void fill_with_bits_of_field_element(protoboard<FieldT> &pb, const FieldT &r) const;
 
     std::vector<FieldT> get_vals(const protoboard<FieldT> &pb) const;
@@ -120,7 +120,7 @@ public:
 
     void fill_with_field_elements(protoboard<FieldT> &pb, const std::vector<FieldT>& vals) const;
     void fill_with_bits(protoboard<FieldT> &pb, const bit_vector& bits) const;
-    void fill_with_bits_of_ulong(protoboard<FieldT> &pb, const unsigned long i) const;
+    void fill_with_bits_of_ulong(protoboard<FieldT> &pb, const uint64_t i) const;
     void fill_with_bits_of_field_element(protoboard<FieldT> &pb, const FieldT &r) const;
 
     std::vector<FieldT> get_vals(const protoboard<FieldT> &pb) const;
diff --git a/src/snark/libsnark/gadgetlib1/pb_variable.tcc b/src/snark/libsnark/gadgetlib1/pb_variable.tcc
index b36b3f8..77c9f13 100644
--- a/src/snark/libsnark/gadgetlib1/pb_variable.tcc
+++ b/src/snark/libsnark/gadgetlib1/pb_variable.tcc
@@ -65,7 +65,7 @@ void pb_variable_array<FieldT>::fill_with_bits_of_field_element(protoboard<Field
 }
 
 template<typename FieldT>
-void pb_variable_array<FieldT>::fill_with_bits_of_ulong(protoboard<FieldT> &pb, const unsigned long i) const
+void pb_variable_array<FieldT>::fill_with_bits_of_ulong(protoboard<FieldT> &pb, const uint64_t i) const
 {
     this->fill_with_bits_of_field_element(pb, FieldT(i, true));
 }
@@ -232,7 +232,7 @@ void pb_linear_combination_array<FieldT>::fill_with_bits_of_field_element(protob
 }
 
 template<typename FieldT>
-void pb_linear_combination_array<FieldT>::fill_with_bits_of_ulong(protoboard<FieldT> &pb, const unsigned long i) const
+void pb_linear_combination_array<FieldT>::fill_with_bits_of_ulong(protoboard<FieldT> &pb, const uint64_t i) const
 {
     this->fill_with_bits_of_field_element(pb, FieldT(i));
 }
diff --git a/src/snark/libsnark/relations/arithmetic_programs/qap/tests/test_qap.cpp b/src/snark/libsnark/relations/arithmetic_programs/qap/tests/test_qap.cpp
index e20f589..3c7b870 100644
--- a/src/snark/libsnark/relations/arithmetic_programs/qap/tests/test_qap.cpp
+++ b/src/snark/libsnark/relations/arithmetic_programs/qap/tests/test_qap.cpp
@@ -92,13 +92,13 @@ TEST(relations, qap)
 
     enter_block("Test QAP with binary input");
 
-    test_qap<Fr<alt_bn128_pp> >(1ul << 21, num_inputs, true);
+    test_qap<Fr<alt_bn128_pp> >(UINT64_C(1) << 21, num_inputs, true);
 
     leave_block("Test QAP with binary input");
 
     enter_block("Test QAP with field input");
 
-    test_qap<Fr<alt_bn128_pp> >(1ul << 21, num_inputs, false);
+    test_qap<Fr<alt_bn128_pp> >(UINT64_C(1) << 21, num_inputs, false);
 
     leave_block("Test QAP with field input");
 }
diff --git a/src/snark/libsnark/relations/variable.hpp b/src/snark/libsnark/relations/variable.hpp
index 8c2c704..84c65e8 100644
--- a/src/snark/libsnark/relations/variable.hpp
+++ b/src/snark/libsnark/relations/variable.hpp
@@ -26,7 +26,7 @@ namespace libsnark {
  * Mnemonic typedefs.
  */
 typedef size_t var_index_t;
-typedef long integer_coeff_t;
+typedef int64_t integer_coeff_t;
 
 /**
  * Forward declaration.
diff --git a/src/test/rpc_wallet_tests.cpp b/src/test/rpc_wallet_tests.cpp
index 42590c3..a49be82 100644
--- a/src/test/rpc_wallet_tests.cpp
+++ b/src/test/rpc_wallet_tests.cpp
@@ -403,7 +403,7 @@ BOOST_AUTO_TEST_CASE(rpc_wallet_z_exportwallet)
     BOOST_CHECK_THROW(CallRPC(string("z_exportwallet ") + tmpfilename.string()), runtime_error);
 
     // set exportdir
-    mapArgs["-exportdir"] = tmppath.native();
+    mapArgs["-exportdir"] = tmppath.string();
 
     // run some tests
     BOOST_CHECK_THROW(CallRPC("z_exportwallet"), runtime_error);
@@ -483,7 +483,7 @@ BOOST_AUTO_TEST_CASE(rpc_wallet_z_importwallet)
     // write test data to file
     boost::filesystem::path temp = boost::filesystem::temp_directory_path() /
             boost::filesystem::unique_path();
-    const std::string path = temp.native();
+    const std::string path = temp.string();
     std::ofstream file(path);
     file << testWalletDump;
     file << std::flush;
diff --git a/zcutil/build.sh b/zcutil/build.sh
index 85ff853..1702776 100755
--- a/zcutil/build.sh
+++ b/zcutil/build.sh
@@ -33,14 +33,6 @@ if [[ -z "${HOST-}" ]]; then
     HOST="$BUILD"
 fi
 
-# Allow override to $CC and $CXX for porters. Most users will not need it.
-if [[ -z "${CC-}" ]]; then
-    CC=gcc
-fi
-if [[ -z "${CXX-}" ]]; then
-    CXX=g++
-fi
-
 # Allow users to set arbitary compile flags. Most users will not need this.
 if [[ -z "${CONFIGURE_FLAGS-}" ]]; then
     CONFIGURE_FLAGS=""
@@ -105,15 +97,11 @@ then
     shift
 fi
 
-PREFIX="$(pwd)/depends/$BUILD/"
-
 eval "$MAKE" --version
-eval "$CC" --version
-eval "$CXX" --version
 as --version
 ld -v
 
 HOST="$HOST" BUILD="$BUILD" NO_PROTON="$PROTON_ARG" "$MAKE" "$@" -C ./depends/ V=1
 ./autogen.sh
-CC="$CC" CXX="$CXX" ./configure --prefix="${PREFIX}" --host="$HOST" --build="$BUILD" "$HARDENING_ARG" "$LCOV_ARG" "$TEST_ARG" "$MINING_ARG" "$PROTON_ARG" $CONFIGURE_FLAGS --enable-werror CXXFLAGS='-g'
+CONFIG_SITE="$PWD/depends/$HOST/share/config.site" ./configure "$HARDENING_ARG" "$LCOV_ARG" "$TEST_ARG" "$MINING_ARG" "$PROTON_ARG" $CONFIGURE_FLAGS --enable-static --disable-shared CXXFLAGS='-g'
 "$MAKE" "$@" V=1
